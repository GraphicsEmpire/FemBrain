/*
 * PS_VegWriter.cpp
 *
 *  Created on: Oct 3, 2012
 *      Author: pourya
 */

#include <iostream>
#include <fstream>
#include <vector>
#include "PS_VegWriter.h"
#include "base/String.h"
#include "base/FileDirectory.h"
#include "base/Vec.h"


using namespace std;
using namespace PS;
using namespace PS::FILESTRINGUTILS;
using namespace PS::MATH;

class MeshReader{
public:
	MeshReader() {}
	virtual ~MeshReader() {
		vertices.resize(0);
		elements.resize(0);
	}

	int readVertices(const char* lpVertexFP);
	int readElements(const char* lpElementFP);
public:
	std::vector< vec3d > vertices;
	std::vector< vec4i > elements;
};

int MeshReader::readVertices(const char* lpVertexFP)
{
	char chrLine[2048];
	ifstream fpIn(lpVertexFP);
	if(!fpIn.is_open())
		return -1;

	int ctLine = 0;
	int idxVertex = 0;
	while(!fpIn.eof())
	{
		fpIn.getline(chrLine, 2048);

		AnsiStr strLine(chrLine);
		strLine.removeStartEndSpaces();
		strLine.trim();
		if(strLine.firstChar() == '#')
			continue;
		if(strLine.length() == 0)
			break;

		if(ctLine == 0)
		{
			int ctVertices;
			int ctCoords;
			sscanf(strLine.cptr(), "%d %d", &ctVertices, &ctCoords);

			if(ctVertices <= 0 || ctCoords != 3)
			{
				fpIn.close();
				return false;
			}

			vertices.resize(ctVertices);
		}
		else
		{
			vec3d v;
			vector<AnsiStr> arrWords;
			int ctWords = strLine.decompose(' ', arrWords);
			if(ctWords >= 4)
			{
				int temp = atoi(arrWords[0].cptr());
				v.x = atof(arrWords[1].cptr());
				v.y = atof(arrWords[2].cptr());
				v.z = atof(arrWords[3].cptr());
			}
			//sscanf(strLine.cptr(), "%d %f %f %f", &temp, &v.x, &v.y, &v.z);

			vertices[idxVertex] = v;
			idxVertex++;
		}

		ctLine++;
	}
	fpIn.close();
	return vertices.size();
}

int MeshReader::readElements(const char* lpElementFP)
{
	char chrLine[2048];
	ifstream fpIn(lpElementFP);
	if(!fpIn.is_open())
		return -1;

	int ctLine = 0;
	int idxElement = 0;
	while(!fpIn.eof())
	{
		fpIn.getline(chrLine, 2048);

		AnsiStr strLine(chrLine);
		strLine.removeStartEndSpaces();
		strLine.trim();
		if(strLine.firstChar() == '#')
			continue;
		if(strLine.length() == 0)
			break;

		if(ctLine == 0)
		{
			int ctElements;
			int ctCoords;
			sscanf(strLine.cptr(), "%d %d", &ctElements, &ctCoords);

			if(ctElements <= 0 || ctCoords != 4)
			{
				fpIn.close();
				return false;
			}

			elements.resize(ctElements);
		}
		else
		{
			int temp;
			vec4i e;
			sscanf(strLine.cptr(), "%d %d %d %d %d", &temp, &e.x, &e.y, &e.z, &e.w);

			elements[idxElement] = e;
			idxElement++;
		}

		ctLine++;
	}


	fpIn.close();
	return elements.size();
}

/*!
 * Reads the input node file and the Elements file and attaches them to create a
 * single veg file.
 */
int VegWriter::WriteVegFile(const char* lpInputNodeFile)
{
	AnsiStr strFilePath(lpInputNodeFile);
	AnsiStr strExt = ExtractFileExt(strFilePath);
	if(strExt != "node")
		return -1;

	AnsiStr strElementFP = ChangeFileExt(strFilePath, ".ele");
	MeshReader mesh;
	mesh.readVertices(lpInputNodeFile);
	mesh.readElements(strElementFP.cptr());


	//Output veg file
	AnsiStr strVegFP = ChangeFileExt(strFilePath, ".veg");
	ofstream fpOut(strVegFP.cptr());

	//Include Node File
	fpOut << "# Vega Mesh File, Generated by FemBrain.\n";
	fpOut << "# " << mesh.vertices.size() << " vertices, " << mesh.elements.size() << " elements\n";
	fpOut << "\n";
	fpOut << "*VERTICES\n";
	fpOut << mesh.vertices.size() << " 3 0 0\n";

	for(int i=0; i < mesh.vertices.size(); i++)
	{
		vec3d v = mesh.vertices[i];

		//VEGA expects one based index for everything
		fpOut << i+1 << " " << v.x << " " << v.y << " " << v.z << "\n";
 	}

	//Line Separator
	fpOut << "\n";
	fpOut << "*ELEMENTS\n";
	fpOut << "TET\n";
	fpOut << mesh.elements.size() << " 4 0\n";

	for(int i=0; i < (int)mesh.elements.size(); i++)
	{
		vec4i e = mesh.elements[i];

		//VEGA expects one based index for everything
		fpOut << i+1 << " " << e.x+1 << " " << e.y+1 << " " << e.z+1 << " " << e.w+1 << "\n";
 	}

	//Add Default Material
	fpOut << "\n";
	fpOut << "*MATERIAL BODY\n";
	fpOut << "ENU, 1000, 10000000, 0.45\n";

	fpOut << "\n";
	fpOut << "*REGION\n";
	fpOut << "allElements, BODY\n";

	//Include Element File
	fpOut.close();


	return 1;
}



